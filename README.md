# CSS

**CSS (Cascading Style Sheets)** — каскадні таблиці стилів, які застосовуються для візуального форматування документу в мовах розмітки. CSS використовується для того, щоб визначити кольори, шрифти, верстку та інші аспекти вигляду сторінки.

**Основна ідея CSS** в тому, щоб відокремити дизайн документу від його вмісту. Тобто CSS відповідає за оформлення і зовнішній вигляд, а HTML — за зміст і логічну структуру документу

### Селектори (елементи, класи, ідентифікатори, комбіновані селектори)

**Селектори** - це спеціальні конструкції в CSS, що використовуються для вибору елементів на сторінці і задання стилів цим елементам.

**Елементи** - це назви тегів HTML, наприклад, `p`, `div`, `img`, a і т.д. Застосування селектора елементів означає вибір всіх елементів зі специфікованим тегом на сторінці і задання для них стилів.

Звичайний (елементний) селектор використовує ім'я HTML-елемента для визначення стилів:

`p {`

  `color: red;`
  
`}`

Це застосує червоний колір до всіх елементів `<p>` на сторінці.

**Класи** - це іменовані атрибути, які можуть бути присвоєні до елементів HTML, щоб ідентифікувати їх для застосування стилів. Класи використовуються з селекторами класів, які починаються з крапки, наприклад, `.example`.

Селектор класу використовує назву класу CSS, яка починається з крапки, для визначення стилів:

`.my-class {`

  `font-size: 16px;`
  
`}`

Це застосує розмір шрифту 16 пікселів до всіх елементів з класом `my-class` на сторінці.

**Ідентифікатори** - це унікальні атрибути, які можуть бути присвоєні до елементів HTML, щоб ідентифікувати їх для застосування стилів. Ідентифікатори використовуються з селекторами ідентифікаторів, які починаються з хеш-символу, наприклад, `#example`.


Селектор ідентифікатора використовує назву ідентифікатора CSS, яка починається з хеша, для визначення стилів:

`#my-id {`

 `background-color: blue;`
  
`}`

Це застосує синій фон до елемента з ідентифікатором `my-id` на сторінці.

**Комбіновані селектори** - це селектори, що поєднуються разом для вибору елементів зі специфікованими властивостями. Наприклад, комбінований селектор може вибрати всі елементи з певним класом, що знаходяться всередині іншого елемента з ідентифікатором. Такі комбіновані селектори можуть бути виконані за допомогою пробілів, знаків більше-менше та інших операторів комбінації.

Комбіновані селектори поєднують два або більше селектори для визначення стилів для елементів, які мають обидва селектори:

`h1.my-heading {`

  `color: green;`
  
`}`

Це застосує зелений колір до всіх елементів `<h1>` з класом `my-heading` на сторінці.

### Наслідування та каскадування

**Наслідування в CSS** - механізм, за допомогою якого значення властивостей елемента-батька передаються його елементам-нащадкам. Стилі, присвоєні деякого елементу, успадковуються всіма нащадками (вкладеними елементами), якщо вони не перевизначені (перекриті) явно. Наприклад, розмір шрифту і його колір досить часто застосувати до `body`, щоб всі елементи всередині мали ті ж властивості. Наслідування дозволяє скоротити розмір таблиці стилів, але якщо стилів багато, то відстежити який батьківський елемент встановив певну властивість стає складніше.

`<p class = "text">` Рядок з виділеним `<span>` словом `</span>` `<p>`

Задаємо CSS-властивості:

`.text {`

`color: red;`

`}`

Завдяки наслідуванню колір шрифту в тезі `span` автоматично стане червоним:


**Наслідування властивості**

До спадкоємною властивостей відносяться в першу чергу властивості, що визначають параметри відображення тексту: `font-size`, `font-family`, `font-style`, `font-weight`, `color`, `text-align`, `text-transform`, `text-indent`, `line-height`, `letter-spacing`, `word-spacing`, `white-space`, `direction` і т. д.
Ці властивості можна і потрібно задавати через предків, слідуючи семантиці документа. Наприклад, параметри тексту часто не змінюються в межах окремих блоків сторінки: меню, основного змісту, інформаційних панелей. Тому загальні параметри тексту (колір, розмір, гарнітура) зазвичай вказують в стилях самих блоків/

**Ненаслідувані властивості**

Це параметри `позиціонування`, `розмірів`, `відступів`, `фону`, `рамок` і т. д. А саме: `background`, `border`, `padding`, `margin`, `width`, `height`, `position` і ін. Весь список ненаслідуваних властивостей дивіться в стандарті CSS. 


**Каскадність**

CSS розшифровується як `«Cascading Style Sheets»` або `«каскадні таблиці стилів»`. Каскадність означає, що до одного і того ж елементу може застосовуватися кілька CSS-правил (наборів CSS-властивостей). Серед цих властивостей можуть бути і конфліктуючі між собою. Тому існують інструкції, які визначають, яким буде фінальний набір властивостей елемента. Наприклад, для елемента:

`<p class = "text" style = "color: red;"> </ p>`

CSS-правила існують як мінімум в трьох різних місцях:

- в файлі, що підключається `style.css` для селекторів `p` або `.text`;
- в атрибуті `style`;
- в стандартних стилях відображення, вбудованих в браузер.

Каскадність якраз і визначає, які саме властивості з цих джерел застосуються до даного абзацу. Є три основні концепції, керуючі порядком, в якому застосовуються CSS-властивості:

- важливість;
- специфічність;
- порядок вихідного коду.

Приклад:

`<p class = "red blue">` Синій або червоний? `</ p>`

А ось CSS-код c двома правилами для цих класів:

`.blue {`

`color: blue;`

`}`

`.red {`

`color: red;`

`}`

Червоного кольору, друге правило пріорітетніше.
Це відбувається тому, що селектори у правил однакового типу, і відповідно мають однакову специфічність. В такому випадку більш високим пріоритетом володіє те правило, що розташоване в CSS-коді нижче в нашому випадку це правило для класу `red`.

Трохи інший CSS:

`<p class = "red blue">` Синій або червоний? `</ p>`

`p.blue {`

 `color: blue;`
 
`}`

`.red {`

`color: red;`

`}`

У цьому випадку текст абзацу буде синім. Тому, що селектор `p.blue` більш специфічний, ніж селектор `.red.` Просте пояснення специфічності звучить так: чим менша кількість елементів потенційно може вибрати селектор, тим він специфічніше. В цьому прикладі селектор `.red` вибере всі теги з потрібним класом, а селектор `p.blue` вибере тільки абзаци з потрібним класом.

### Розмір і положення блоків (ширина, висота, margin, padding, position)

**Розмір і положення** блоків в CSS можуть бути встановлені за допомогою різних властивостей, таких як `ширина`, `висота`, `margin`, `padding` і `position`.

**Ширина (width)** - Властивість `width` встановлює ширину елемента. Її значення може бути вказано в `пікселях`, `відсотках`, `em`, `rem` та інших одиницях виміру. 

`.box {`

  `width: 200px;`
  
`}`

**Висота (height)** - Властивість `height` встановлює висоту елемента. Вона також може бути вказана в `пікселях`, `відсотках`, `em`, `rem` та інших одиницях виміру.

`.box {`

  `height: 150px;`
  
`}`

**Margin** - Властивість margin встановлює зовнішні відступи блока, тобто простір між блоком і його сусідніми елементами. Значення margin може бути вказане для кожної сторони блока (верхньої, нижньої, лівої і правої) окремо або в одному значенні для всіх сторін одночасно.

`.box {`

    `margin-top: 10px;`
    
    `margin-bottom: 20px;`
    
    `margin-left: 5px;`
    
    `margin-right: 5px;`
    
`}`

Або

`.box {`

     `margin: 10px 5px 20px 5px;`
     
`}`


**Padding** - Властивість padding встановлює внутрішні відступи блока, тобто простір між вмістом блока і його межами. Значення padding також може бути вказане для кожної сторони окремо або в одному значенні для всіх сторін одночасно.

`.box {`
  `padding-top: 10px;`
  `padding-bottom: 20px;`
  `padding-left: 5px;`
  `padding-right: 5px;`
`}`

Або

`.box {`

 `padding: 10px 5px 20px 5px;`
 
`}`

**Position** - Властивість position встановлює тип позиціонування елемента. Існують різні значення для `position`, такі як `static`, `relative`, `absolute`, `fixed` і `sticky`, кожне з яких має свої особливості.

**Static** - Елемент розміщується у властивому потоці документа. Це значення за замовчуванням.

**Relative** - Елемент розміщується відносно свого звичайного положення. Можна використовувати властивості `top`, `bottom`, `left` і `right` для зміни положення елемента.

**Absolute** - Елемент розміщується відносно найближчого позиціонованого предка. Він вилучається зі звичайного потоку документа.

**Fixed** - Елемент розміщується відносно вікна перегляду. Він залишається на одному місці, незалежно від прокрутки сторінки.

**Sticky** - Елемент спочатку поводиться як `relative`, але при прокручуванні він "прилипає" до визначеної позиції на екрані.

`.box {`

     `position: relative;`
     
     `top: 20px;`
     
     `left: 50px;`
     
`}`


Це лише деякі з основних властивостей CSS для встановлення розміру і положення блоків. CSS має багато інших властивостей, які можна використовувати для стилізації та позиціонування елементів на сторінці.

### Кольори та фон (color, background-color, opacity, gradient)

**Колір (color)** -Властивість color використовується для задання кольору тексту або значень. Значення можуть бути задані в різних форматах, таких як назва кольору, шістнадцятковий код, RGB-код або HSL-код.

`.text {`

    `color: red; /* Встановлює колір тексту на червоний */`
  
`}`

`.value {`

  `color: #336699; /* Встановлює колір тексту за шістнадцятковим кодом */`
  
`}`

`.background {`

  `color: rgb(255, 0, 0); /* Встановлює колір тексту за RGB-кодом */`
  
`}`

**Колір фону (background-color)** - Властивість background-color встановлює колір фону елемента. Значення можуть бути задані в тому ж форматі, що й для властивості `color`.

`.container {`

  `background-color: #f0f0f0; /* Встановлює колір фону на світло-сірий */`
  
`}`

**Непрозорість (opacity)** - Властивість opacity встановлює прозорість елемента від 0 до 1, де 0 - повна прозорість, а 1 - повна непрозорість.

`.box {`

  `opacity: 0.5; /* Встановлює непрозорість на 50% */`
  
`}`


**Градієнт (gradient)** - Властивість background-image використовується для створення градієнтного фону, що поступово змінюється від одного кольору до іншого. Градієнт може бути лінійним або радіальним.

`.linear-gradient {`

  `background-image: linear-gradient(to right, red, blue); /* Лінійний градієнт від червоного до синього */`
  
`}`

`.radial-gradient {`

  `background-image: radial-gradient(circle at center, orange, yellow); /* Радіальний градієнт від помаранчевого до жовтого */`
  
`}`

Використання цих властивостей дозволяє керувати кольором тексту, фоном, прозорістю та створювати градієнтні ефекти для елементів на сторінці.

### Шрифти (font-family, font-size, font-weight, text-align)

**Сімейство шрифтів (font-family)** - Властивість `font-family` використовується для встановлення шрифтового сімейства тексту. Можна задати кілька шрифтів у порядку пріоритету, щоб браузер використовував перший доступний шрифт.

`body {`

  `font-family: Arial, sans-serif; /* Встановлює шрифт Arial або, якщо недоступний, будь-який шрифт без засічок */`
  
`}`


**Розмір шрифту (font-size)** - Властивість `font-size` встановлює розмір шрифту для тексту.

`h1 {`

  `font-size: 24px; /* Встановлює розмір шрифту заголовків h1 на 24 пікселі */`
  
`}`

**Насиченість шрифту (font-weight)** - Властивість `font-weight` використовується для встановлення насиченості шрифту, тобто товщини символів.

`strong {`

  `font-weight: bold; /* Встановлює насиченість шрифту для елементів <strong> на жирний */`
  
`}`

**Вирівнювання тексту (text-align)** - Властивість `text-align` встановлює вирівнювання тексту в межах елемента.

`p {`

  `text-align: center; /* Вирівнює текст параграфів по центру */`
  
`}`

Використовуючи ці властивості, можна контролювати шрифти, їх розміри, насиченість та вирівнювання тексту для різних елементів на сторінці.


### Flexbox і Grid для розміщення елементів на сторінці

**Flexbox і Grid** - це дві потужні техніки в CSS, які дозволяють легко та гнучко розміщувати елементи на сторінці.

**Flexbox** - використовує модель контейнера та елементів, які впорядковуються вздовж одного або двох напрямків. Він дозволяє гнучко керувати розташуванням, розміром та порядком елементів у контейнері.

`.container {`

  `display: flex;`
  
  `justify-content: center;`
  
  `align-items: center;`
  
`}`


`.item {`

  `flex: 1;`
  
`}`


**Grid** - дозволяє створювати сітку з рядками та стовпцями, в якій елементи можуть розташовуватись. Він забезпечує потужні можливості для розміщення елементів у двовимірному просторі.

`.container {`

  `display: grid;`
  
  `grid-template-columns: 1fr 1fr 1fr;`
  
  `grid-gap: 10px;`
  
`}`

`.item {`

  `grid-column: span 2;`
  
  `grid-row: 1;`
  
`}`

За допомогою Flexbox та Grid можна легко створювати складні макети та розташування елементів на сторінці, дозволяючи легко пристосовувати їх до різних розмірів екрану та вікон браузера.


### Медіа-запити для адаптивного дизайну

**Медіа-запити (Media Queries)** - це механізм в CSS, який дозволяє застосовувати різні стилі до елементів залежно від характеристик пристрою, на якому відображається веб-сторінка. Вони використовуються для створення адаптивного дизайну, що забезпечує оптимальне відображення сторінки на різних пристроях з різними розмірами екрану.

Медіа-запити визначаються за допомогою `@media` правила і можуть містити умови, які базуються на характеристиках пристрою, таких як ширина екрану, орієнтація, роздільна здатність та інші.

Приклади медіа-запитів:

**Застосування стилів для екранів з шириною менше 768 пікселів:**

`@media (max-width: 768px) {`

  `/* Стилі, які будуть застосовуватись на екранах з шириною менше 768px */`
  
  `/* Наприклад, зміна розміру шрифту або перестановка елементів */`
  
`}`

**Застосування стилів для екранів з роздільною здатністю більше 1200 пікселів та портретної орієнтації:**

`@media (min-width: 1200px) and (orientation: portrait) {`

  `/* Стилі, які будуть застосовуватись на екранах з роздільною здатністю більше 1200px та портретної орієнтації */`
  
  `/* Наприклад, зміна фонового кольору або розміру блоків */`
  
`}`

**Застосування стилів для друкованих сторінок:**

`@media print {`

  `/* Стилі, які будуть застосовуватись при друку сторінки */`
  
  `/* Наприклад, приховування деяких елементів або зміна розміру зображень */`
  
`}`

За допомогою медіа-запитів можна створювати адаптивний дизайн, який забезпечує зручне та оптимальне відображення веб-сторінки на різних пристроях та в різних умовах використання.





























